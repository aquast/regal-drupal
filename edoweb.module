<?php

/**
 * @file
 * Implements the basic functionality required to create and display an entity.
 *
 * This example does not use the
 * @link http://drupal.org/project/entity Entity API module @endlink, which is
 * used by many entity implementations and is recommended by many.
 *
 * An example of use of creating and managing entities using the Entity API
 * module is provided in the
 * @link http://drupal.org/project/model Model Entity module @endlink.
 *
 * @todo: Reference the ronald_istos article series
 * @todo: Reference the Drupal module development book
 * @todo: Add a single field
 */

require_once dirname(__FILE__) . '/lib/LibRDF/LibRDF/LibRDF.php';
require_once dirname(__FILE__) . '/lib/php-json-ld/jsonld.php';

/**
 * Implements hook_entity_info().
 *
 * This is the fundamental description of the entity.
 *
 * It provides a single entity with a single bundle and without revision
 * support.
 */
function edoweb_entity_info() {
  $info['edoweb_basic'] = array(
    // A human readable label to identify our entity.
    'label' => t('Edoweb Basic Entity'),

    // The controller for our Entity, extending the Drupal core controller.
    'controller class' => 'EdowebBasicController',

    // The table for this entity defined in hook_schema()
    'base table' => 'edoweb_basic',

    // Returns the uri elements of an entity
    'uri callback' => 'edoweb_basic_uri',

    // IF fieldable == FALSE, we can't attach fields.
    'fieldable' => TRUE,

    // entity_keys tells the controller what database fields are used for key
    // functions. It is not required if we don't have bundles or revisions.
    // Here we do not support a revision, so that entity key is omitted.
    'entity keys' => array(
      'id' => 'basic_id' , // The 'id' (basic_id here) is the unique id.
      'bundle' => 'bundle_type' // Bundle will be determined by the 'bundle_type' field
    ),
    'bundle keys' => array(
      'bundle' => 'bundle_type',
    ),

    // FALSE disables caching. Caching functionality is handled by Drupal core.
    'static cache' => FALSE,

    // FALSE disables caching. Caching functionality is handled by Drupal core.
    'field cache' => FALSE,

    // Bundles are alternative groups of fields or configuration
    // associated with a base entity type.
    'bundles' => array(
      'monograph_bundle' => array(
        'label' => 'First example bundle',
        // 'admin' key is used by the Field UI to provide field and
        // display UI pages.
        'admin' => array(
          'path' => 'admin/structure/edoweb_basic/manage',
          'access arguments' => array('administer edoweb_basic entities'),
        ),
      ),
    ),
    // View modes allow entities to be displayed differently based on context.
    // As a demonstration we'll support "Tweaky", but we could have and support
    // multiple display modes.
    'view modes' => array(
      'tweaky' => array(
        'label' => t('Tweaky'),
        'custom settings' =>  FALSE,
      ),
    )
  );

  return $info;
}

/**
 * Fetch a basic object.
 *
 * This function ends up being a shim between the menu system and
 * edoweb_basic_load_multiple().
 *
 * This function gets its name from the menu system's wildcard
 * naming conventions. For example, /path/%wildcard would end
 * up calling wildcard_load(%wildcard value). In our case defining
 * the path: edoweb/resource/basic/%edoweb_basic in
 * hook_menu() tells Drupal to call edoweb_basic_load().
 *
 * @param $basic_id
 *   Integer specifying the basic entity id.
 * @param $reset
 *   A boolean indicating that the internal cache should be reset.
 * @return
 *   A fully-loaded $basic object or FALSE if it cannot be loaded.
 *
 * @see edoweb_basic_load_multiple()
 * @see edoweb_menu()
 */
function edoweb_basic_load($basic_id = NULL, $reset = FALSE) {
  $basic_ids = (isset($basic_id) ? array($basic_id) : array());
  $basic = edoweb_basic_load_multiple($basic_ids, array(), $reset);
  return $basic ? reset($basic) : FALSE;
}

/**
 * Loads multiple basic entities.
 *
 * We only need to pass this request along to entity_load(), which
 * will in turn call the load() method of our entity controller class.
 */
function edoweb_basic_load_multiple($basic_ids = FALSE, $conditions = array(), $reset = FALSE) {
  return entity_load('edoweb_basic', $basic_ids, $conditions, $reset);
}

/**
 * Implements the uri callback.
 */
function edoweb_basic_uri($basic) {
  return array(
    'path' => 'edoweb/resource/basic/' . $basic->basic_id,
  );
}

/**
 * Implements hook_menu().
 */
function edoweb_menu() {
  $items['edoweb/resource'] = array(
    'title' => 'Edoweb',
    'page callback' => 'edoweb_info_page',
    'access arguments' => array('view any edoweb_basic entity'),
  );

  // This provides a place for Field API to hang its own
  // interface and has to be the same as what was defined
  // in basic_entity_info() above.
  $items['admin/structure/edoweb_basic/manage'] = array(
    'title' => 'Administer edoweb_basic entity type',
    'page callback' => 'edoweb_basic_admin_page',
    'access arguments' => array('administer edoweb_basic entities'),
  );

  // The page to view our entities - needs to follow what
  // is defined in basic_uri and will use load_basic to retrieve
  // the necessary entity info.
  $items['edoweb/resource/basic/%edoweb_basic'] = array(
    'title callback' => 'edoweb_basic_title',
    'title arguments' => array(3),
    'page callback' => 'edoweb_basic_view',
    'page arguments' => array(3),
    'access arguments' => array('view any edoweb_basic entity'),
  );

  // 'View' tab for an individual entity page.
  $items['edoweb/resource/basic/%edoweb_basic/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  // 'Edit' tab for an individual entity page.
  $items['edoweb/resource/basic/%edoweb_basic/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('edoweb_basic_form', 3),
    'access arguments' => array('edit any edoweb_basic entity'),
    'type' => MENU_LOCAL_TASK,
  );

  // Add example entities.
  $items['edoweb/resource/basic/add'] = array(
    'title' => 'Add an Edoweb Basic Entity',
    'page callback' => 'edoweb_basic_add',
    'access arguments' => array('create edoweb_basic entities'),
  );

  // Import example entities.
  $items['edoweb/resource/basic/import'] = array(
    'title' => 'Import an Edoweb Basic Entity',
    'page callback' => 'edoweb_basic_import',
    'access arguments' => array('create edoweb_basic entities'),
  );

  return $items;
}

/**
 * Basic information for the page.
 */
function edoweb_info_page() {
  $content['preface'] = array(
    '#type' => 'item',
    '#markup' => t('List of Edoweb entities')
  );
  if (user_access('administer edoweb_basic entities')) {
    $content['preface']['#markup'] =  t('You can administer these and add fields and change the view !link.',
      array('!link' => l(t('here'), 'admin/structure/edoweb_basic/manage'))
    );
  }
  $content['table'] = edoweb_basic_list_entities();

  return $content;
}

/**
 * Implements hook_permission().
 */
function edoweb_permission() {
  $permissions = array(
    'administer edoweb_basic entities' =>  array(
      'title' => t('Administer edoweb_basic entities'),
    ),
    'view any edoweb_basic entity' => array(
      'title' => t('View any Edoweb Basic entity'),
    ),
    'edit any edoweb_basic entity' => array(
      'title' => t('Edit any Edoweb Basic entity'),
    ),
    'create edoweb_basic entities' => array(
      'title' => t('Create Edoweb Basic Entities'),
    ),
  );
  return $permissions;
}


/**
 * Provides a list of existing entities and the ability to add more. Tabs
 * provide field and display management.
 */
function edoweb_basic_admin_page() {
  $content = array();
  $content[] = array(
    '#type' => 'item',
    '#markup' => t('Administration page for Edoweb Basic Entities.')
  );

  $content[] = array(
    '#type' => 'item',
    '#markup' => l(t('Add an edoweb_basic entity'), 'edoweb/resource/basic/add'),
  );

  $content['table'] = edoweb_basic_list_entities();

  return $content;
}

/**
 * Returns a render array with all edoweb_basic entities.
 *
 * In this basic example we know that there won't be many entities,
 * so we'll just load them all for display. See pager_example.module
 * to implement a pager. Most implementations would probably do this
 * with the contrib Entity API module, or a view using views module,
 * but we avoid using non-core features in the Examples project.
 *
 * @see pager_example.module
 */
function edoweb_basic_list_entities() {
  $content = array();
  // Load all of our entities.
  $entities = edoweb_basic_load_multiple();
  if (!empty($entities)) {
    foreach ( $entities as $entity ) {
      // Create tabular rows for our entities.
      $rows[] = array(
        'data' => array(
          'id' => l($entity->basic_id, 'edoweb/resource/basic/' . $entity->basic_id),
          'bundle' => $entity->bundle_type,
        ),
      );
    }
    // Put our entities into a themed table. See theme_table() for details.
    $content['entity_table'] = array(
      '#theme' => 'table',
      '#rows' => $rows,
      '#header' => array(t('ID'), t('Bundle')),
    );
  }
  else {
    // There were no entities. Tell the user.
    $content[] = array(
      '#type' => 'item',
      '#markup' => t('No edoweb_basic entities currently exist.'),
    );
  }
  return $content;
}

/**
 * Callback for a page title when this entity is displayed.
 */
function edoweb_basic_title($entity) {
  return t('Edoweb Basic (id=@id)', array('@id' => $entity->basic_id));
}

/**
 * Menu callback to display an entity.
 *
 * As we load the entity for display, we're responsible for invoking a number
 * of hooks in their proper order.
 *
 * @see hook_entity_prepare_view()
 * @see hook_entity_view()
 * @see hook_entity_view_alter()
 */
function edoweb_basic_view($entity, $view_mode = 'tweaky') {
  // Our entity type, for convenience.
  $entity_type = 'edoweb_basic';
  // Start setting up the content.
  $entity->content = array(
    '#view_mode' => $view_mode,
  );
  // Build fields content - this is where the Field API really comes in to play.
  // The task has very little code here because it all gets taken care of by
  // field module.
  // field_attach_prepare_view() lets the fields load any data they need
  // before viewing.
  field_attach_prepare_view($entity_type, array($entity->basic_id => $entity),
    $view_mode);
  // We call entity_prepare_view() so it can invoke hook_entity_prepare_view()
  // for us.
  entity_prepare_view($entity_type, array($entity->basic_id => $entity));
  // Now field_attach_view() generates the content for the fields.
  $entity->content += field_attach_view($entity_type, $entity, $view_mode);

  // OK, Field API done, now we can set up some of our own data.
  $entity->content['created'] = array(
    '#type' => 'item',
    '#title' => t('Created date'),
    '#markup' => format_date($entity->created),
    '#weight' => -1,
  );

  $entity->content['origin'] = array(
    '#type' => 'item',
    '#title' => t('Origin'),
    '#markup' => l($entity->origin, $entity->origin),
    '#weight' => -1,
  );

  $entity->content['turtle'] = array(
    '#type' => 'item',
    '#title' => t('Turtle view'),
    '#markup' => sprintf('<pre>%s</pre>', htmlentities(_edoweb_entity_serialize_turtle($entity))),
    '#weight' => 100,
  );

  $entity->content['json'] = array(
    '#type' => 'item',
    '#title' => t('JSON-LD view'),
    '#markup' => sprintf('<pre>%s</pre>', htmlentities(_edoweb_entity_serialize_jsonld($entity))),
    '#weight' => 100,
  );

  // Now to invoke some hooks. We need the language code for
  // hook_entity_view(), so let's get that.
  global $language ;
  $langcode = $language->language ;
  // And now invoke hook_entity_view().
  module_invoke_all('entity_view', $entity, $entity_type, $view_mode,
    $langcode);
  // Now invoke hook_entity_view_alter().
  drupal_alter(array('edoweb_basic_view', 'entity_view'),
    $entity->content, $entity_type);

  // And finally return the content.
  return $entity->content;
}

/**
 * Implements hook_field_extra_fields().
 *
 * This exposes the "extra fields" (usually properties that can be configured
 * as if they were fields) of the entity as pseudo-fields
 * so that they get handled by the Entity and Field core functionality.
 * Node titles get treated in a similar manner.
 */
function edoweb_field_extra_fields() {
  //$form_elements['item_description'] = array(
  //  'label' => t('Item Description'),
  //   'description' => t('Item Description (an extra form field)'),
  //   'weight' => -5,
  //);
  $display_elements['created'] = array(
    'label' => t('Creation date'),
    'description' => t('Creation date (an extra display field)'),
    'weight' => 0,
  );

  // Since we have only one bundle type, we'll just provide the extra_fields
  // for it here.
  // $extra_fields['edoweb_basic']['monograph_bundle']['form'] = $form_elements;
  $extra_fields['edoweb_basic']['monograph_bundle']['display'] = $display_elements;

  return $extra_fields;
}

/**
 * Provides a wrapper on the edit form to add a new entity.
 */
function edoweb_basic_add() {
  // Create a basic entity structure to be used and passed to the validation
  // and submission functions.
  $entity = entity_get_controller('edoweb_basic')->create();
  return drupal_get_form('edoweb_basic_form', $entity);
}

/**
 * Provides a wrapper on the edit form to add a new entity.
 */
function edoweb_basic_import() {
  return drupal_get_form('edoweb_basic_import_form');
}

function edoweb_basic_import_form($form, &$form_state) {
  $form['resource_id'] = array(
    '#type' => 'textfield',
    '#weight' => 50,
    '#description' => t('Enter the HTTP-URI of the Linked Data resource you want to import.'),
  );
  $form['base_url'] = array(
    '#title' => 'ID Typ',
    '#type' => 'select',
    '#weight' => 75,
    '#options' => array(
      'http://lobid.org/resource/%s' => 'HT Nummer',
      'http://ld.zdb-services.de/resource/%s' => 'ZDB ID',
      '%s' => 'Linked Data URI',
    ),
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Import'),
    '#submit' => array('edoweb_basic_import_submit'),
    '#weight' => 100,
  );
  return $form;
}

function edoweb_basic_import_submit(&$form, &$form_state) {
  // Create a basic entity structure to be used and passed to the validation
  // and submission functions.
  $entity = entity_get_controller('edoweb_basic')->create();
  $api = new LinkedDataClient();
  $resource_id = $form['resource_id']['#value'];
  $base_url = $form['base_url']['#value'];
  $resource_uri = sprintf($base_url, $resource_id);
  try {
    $api->load($entity, $resource_uri);
    drupal_set_message(t("Imported data from ") . $resource_uri, 'status');
  } catch (LibRDF_Error $e) {
    drupal_set_message(t("Failed importing data from ") . $resource_uri, 'error');
  }
  $form_state['redirect'] = false;
  $form = drupal_get_form('edoweb_basic_form', $entity);
  $form['#action'] = url('edoweb/resource/basic/add');
}

/**
 * Form function to create an edoweb_basic entity.
 *
 * The pattern is:
 * - Set up the form for the data that is specific to your
 *   entity: the columns of your base table.
 * - Call on the Field API to pull in the form elements
 *   for fields attached to the entity.
 */
function edoweb_basic_form($form, &$form_state, $entity) {

  $form['basic_entity'] = array(
    '#type' => 'value',
    '#value' => $entity,
  );

  field_attach_form('edoweb_basic', $entity, $form, $form_state);

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
    '#weight' => 100,
  );
  $form['delete'] = array(
    '#type' => 'submit',
    '#value' => t('Delete'),
    '#submit' => array('edoweb_basic_edit_delete'),
    '#weight' => 200,
  );

  return $form;
}


/**
 * Validation handler for edoweb_basic_add_form form.
 * We pass things straight through to the Field API to handle validation
 * of the attached fields.
 */
function edoweb_basic_form_validate($form, &$form_state) {
  field_attach_form_validate('edoweb_basic', $form_state['values']['basic_entity'], $form, $form_state);
}


/**
 * Form submit handler: submits basic_add_form information
 */
function edoweb_basic_form_submit($form, &$form_state) {
  $entity = $form_state['values']['basic_entity'];
  field_attach_submit('edoweb_basic', $entity, $form, $form_state);
  $entity = edoweb_basic_save($entity);
  $form_state['redirect'] = 'edoweb/resource/basic/' . $entity->basic_id;
}

/**
 * Form deletion handler.
 *
 * @todo: 'Are you sure?' message.
 */
function edoweb_basic_edit_delete( $form , &$form_state ) {
  $entity = $form_state['values']['basic_entity'];
  edoweb_basic_delete($entity);
  drupal_set_message(t('The entity %id has been deleted',
    array('%id' => $entity->basic_id))
  );
  $form_state['redirect'] = 'edoweb/resource';
}

/**
 * We save the entity by calling the controller.
 */
function edoweb_basic_save(&$entity) {
  return entity_get_controller('edoweb_basic')->save($entity);
}

/**
 * Use the controller to delete the entity.
 */
function edoweb_basic_delete($entity) {
  entity_get_controller('edoweb_basic')->delete($entity);
}

/**
 * Implements hook_rdf_mapping().
 *
 * This hook should only be used to define the RDF mapping for an entity or
 * bundle that has been defined by this module. On installation, this mapping
 * will be saved to the database. To alter anything in this mapping after module
 * installation (or to alter bundles defined in another module), the RDF CRUD
 * functions should be used, as shown below.
 */
function edoweb_rdf_mapping() {
  return array(
    array(
      'type' => 'edoweb_basic',
      'bundle' => 'monograph_bundle',
      'mapping' => array(
        'rdftype' => array('dc:BibliographicResource', 'frbr:Manifestation'),
        'field_edoweb_title' => array(
          'predicates' => array('isbd:P1004'),
        ),
        'field_edoweb_title_other' => array(
          'predicates' => array('isbd:P1006'),
        ),
        'field_edoweb_creator' => array(
          'predicates' => array('dce:creator'),
        ),
        'field_edoweb_contributor' => array(
          'predicates' => array('dc:contributor'),
        ),
        'field_edoweb_issued' => array(
          'predicates' => array('dc:issued'),
        ),
        'field_edoweb_language' => array(
          'predicates' => array('dc:language'),
        ),
        'field_edoweb_edition' => array(
          'predicates' => array('bibo:edition'),
        ),
        'field_edoweb_publication_place' => array(
          'predicates' => array('isbd:P1016'),
        ),
        'field_edoweb_subject' => array(
          'predicates' => array('dc:subject'),
        ),
        'field_edoweb_publisher' => array(
          'predicates' => array('isbd:P1017'),
        ),
      ),
    ),
  );
}

/*
 * Implements hook_rdf_namespaces().
 *
 * This hook should be used to define any prefixes used by this module that are
 * not already defined in core by entity_rdf_namespaces.
 *
 * http://api.drupal.org/api/drupal/modules--rdf--rdf.api.php/function/hook_rdf_namespaces/7
 */
function edoweb_rdf_namespaces() {
  return array(
    'isbd' => 'http://iflastandards.info/ns/isbd/elements/',
    'frbr' => 'http://purl.org/vocab/frbr/core#',
    'bibo' => 'http://purl.org/ontology/bibo/',
    'dce' => 'http://purl.org/dc/elements/1.1/',
  );
}

/**
 * Implements hook_help().
 */
function edoweb_help($path, $arg) {
  switch ($path) {
    case 'edoweb/resource':
      return "<p>" . t(
        'This Module implements Edoweb functionality'
      ) . "</p>";
  }
}

/*************************
 * Edoweb helper functions
 *************************/

function _edoweb_entity_serialize_turtle($entity) {
  $rdf_subject = new LibRDF_URINode("uuid:{$entity->basic_id}");
  $rdf_serializer = new LibRDF_Serializer('turtle');
  return _edoweb_entity_serialize_rdf($entity, $rdf_subject, $rdf_serializer);
}

function _edoweb_entity_serialize_rdf($entity, $rdf_subject, $rdf_serializer) {
  $rdf_model = new LibRDF_Model(new LibRDF_Storage());
  $rdf_mapping = rdf_mapping_load('edoweb_basic', $entity->bundle_type);
  // First element contains the rdf:type definitions
  $rdf_type_predicate = new LibRDF_URINode(
    'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'
  );
  foreach (array_shift($rdf_mapping) as $rdf_type_mapping) {
    $rdf_type_statement = new LibRDF_Statement(
      $rdf_subject, $rdf_type_predicate,
      new LibRDF_URINode(_edoweb_expand_curie($rdf_type_mapping))
    );
    $rdf_model->addStatement($rdf_type_statement);
  }
  // Following elements contain predicate mappings
  foreach ($rdf_mapping as $field_name => $field_mapping) {
    $rdf_predicate = new LibRDF_URINode(
      _edoweb_expand_curie($field_mapping['predicates'][0])
    );
    $items = field_get_items('edoweb_basic', $entity, $field_name);
    if (TRUE === empty($items)) continue;
    foreach ($items as $item) {
      $rdf_object = new LibRDF_LiteralNode($item['value']);
      $rdf_statement = new LibRDF_Statement(
        $rdf_subject, $rdf_predicate, $rdf_object
      );
      $rdf_model->addStatement($rdf_statement);
    }
  }
  foreach (rdf_get_namespaces() as $prefix => $namespace) {
    _edoweb_log("mapping: $prefix to $namespace\n");
    $rdf_serializer->setNamespace($namespace, $prefix);
  }
  return $rdf_model->serializeStatements($rdf_serializer);
}

function _edoweb_entity_deserialize_rdf($entity, $rdf_subject, $rdf_data, $rdf_parser) {
  $rdf_mapping = rdf_mapping_load('edoweb_basic', $entity->bundle_type);
  $rdf_model = new LibRDF_Model(new LibRDF_Storage());
  $rdf_model->loadStatementsFromString($rdf_parser, $rdf_data);
  LibRDF_LiteralNode::setPlainOutput(true);

  // Skip first element, these are the rdf:type definitions
  unset($rdf_mapping[key($rdf_mapping)]);
  foreach ($rdf_mapping as $field_name => $mapping) {
    $rdf_predicate = new LibRDF_URINode(
      _edoweb_expand_curie($mapping['predicates'][0])
    );
    foreach ($rdf_model->getTargets($rdf_subject, $rdf_predicate) as $value) {
      $entity->{$field_name}['und'][]['value'] = (string) $value;
    }
  }
}

function _edoweb_entity_serialize_jsonld($entity) {
  $rdf_mapping = rdf_mapping_load('edoweb_basic', $entity->bundle_type);
  $jsonld_context = new stdClass();
  $rdf_namespaces = rdf_get_namespaces();
  foreach ($rdf_namespaces as $prefix => $uri) {
    $jsonld_context->{$prefix} = $uri;
  }
  $rdf_subject = new LibRDF_URINode("uuid:{$entity->basic_id}");
  $rdf_serializer = new LibRDF_Serializer('ntriples');
  $rdf_ntriples = _edoweb_entity_serialize_rdf($entity, $rdf_subject, $rdf_serializer);
  $rdf_jsonld = jsonld_compact(jsonld_from_rdf($rdf_ntriples), $jsonld_context);
  return str_replace('\\/', '/', json_encode($rdf_jsonld));
}

function _edoweb_entity_deserialize_jsonld($entity, $rdf_subject, $rdf_data) {
  $options = array();
  $options['format'] = 'application/nquads';
  $rdf_ntriples = jsonld_to_rdf(json_decode($rdf_data), $options);
  $rdf_parser = new LibRDF_Parser('ntriples');
  return _edoweb_entity_deserialize_rdf($entity, $rdf_subject, $rdf_ntriples, $rdf_parser);
}

function _edoweb_log($message, $target='php://stderr') {
  // file_put_contents($target, $message);
}

function _edoweb_expand_curie($curie) {
  $rdf_namespaces = rdf_get_namespaces();
  list($curie_prefix, $curie_local) = explode(':', $curie);
  return $rdf_namespaces[$curie_prefix] . $curie_local;
}

/**
 * EdowebBasicControllerInterface definition.
 *
 * We create an interface here because anyone could come along and
 * use hook_entity_info_alter() to change our controller class.
 * We want to let them know what methods our class needs in order
 * to function with the rest of the module, so here's a handy list.
 *
 * @see hook_entity_info_alter()
 */

interface EdowebBasicControllerInterface
  extends DrupalEntityControllerInterface {
  public function create();
  public function save($entity);
  public function delete($entity);
}

/**
 * EdowebBasicController extends DrupalDefaultEntityController.
 *
 * Our subclass of DrupalDefaultEntityController lets us add a few
 * important create, update, and delete methods.
 */
class EdowebBasicController
  extends DrupalDefaultEntityController
  implements EdowebBasicControllerInterface {

  /**
   * 
   * Generate v4 UUID
   * 
   * Version 4 UUIDs are pseudo-random.
   */
  public static function uuid_v4() {
    return sprintf('%04x%04x-%04x-%04x-%04x-%04x%04x%04x',
      mt_rand(0, 0xffff), mt_rand(0, 0xffff),
      mt_rand(0, 0xffff),
      mt_rand(0, 0x0fff) | 0x4000,
      mt_rand(0, 0x3fff) | 0x8000,
      mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0xffff)
      );
  }

  /**
   * Create and return a new edoweb_basic entity.
   */
  public function create() {
    $entity = new stdClass();
    $entity->type = 'edoweb_basic';
    $entity->basic_id = null;
    $entity->bundle_type = 'monograph_bundle';
    return $entity;
  }

  public function load($ids = array(), $conditions = array()) {
    LibRDF_LiteralNode::setPlainOutput(true);
    $entities = parent::load($ids, $conditions);
    $rdf_parser = new LibRDF_Parser('turtle');
    $edoweb_api_client = new EdowebAPIClient();
    foreach ($entities as $entity) {
      $edoweb_api_client->load($entity);
    }
    return $entities;
  }

  /**
   * Saves the custom fields using drupal_write_record()
   */
  public function save($entity) {
    // If our entity has no basic_id, then we need to give it a
    // time of creation.
    //if (empty($entity->basic_id)) {
      //$entity->created = time();
    //}
    // Invoke hook_entity_presave().
    module_invoke_all('entity_presave', $entity, 'edoweb_basic');
    // The 'primary_keys' argument determines whether this will be an insert
    // or an update. So if the entity already has an ID, we'll specify
    // basic_id as the key.
    $primary_keys = $entity->basic_id ? 'basic_id' : array();
    // Since we are not using auto-increments, we have to manually assign
    // the UUID.
    if (empty($entity->basic_id)) {
      $entity->created = time();
      $entity->basic_id = self::uuid_v4();
    }
    // Write out the entity record.
    drupal_write_record('edoweb_basic', $entity, $primary_keys);
    // We're going to invoke either hook_entity_update() or
    // hook_entity_insert(), depending on whether or not this is a
    // new entity. We'll just store the name of hook_entity_insert()
    // and change it if we need to.
    $invocation = 'entity_insert';
    // Now we need to either insert or update the fields which are
    // attached to this entity. We use the same primary_keys logic
    // to determine whether to update or insert, and which hook we
    // need to invoke.
    if (empty($primary_keys)) {
      field_attach_insert('edoweb_basic', $entity);
    }
    else {
      field_attach_update('edoweb_basic', $entity);
      $invocation = 'entity_update';
    }
    // Invoke either hook_entity_update() or hook_entity_insert().
    module_invoke_all($invocation, $entity, 'edoweb_basic');
    // Store entity via Edoweb API
    $edoweb_api_client = new EdowebAPIClient();
    $edoweb_api_client->save($entity);
    return $entity;
  }

  /**
   * Delete a single entity.
   *
   * Really a convenience function for delete_multiple().
   */
  public function delete($entity) {
    $this->delete_multiple(array($entity));
  }

  /**
   * Delete one or more edoweb_basic entities.
   *
   * Deletion is unfortunately not supported in the base
   * DrupalDefaultEntityController class.
   *
   * @param $basic_ids
   *   An array of entity IDs or a single numeric ID.
   */
  public function delete_multiple($entities) {
    $basic_ids = array();
    if (!empty($entities)) {
      $transaction = db_transaction();
      try {
        foreach ($entities as $entity) {
          // Invoke hook_entity_delete().
          module_invoke_all('entity_delete', $entity, 'edoweb_basic');
          field_attach_delete('edoweb_basic', $entity);
          $basic_ids[] = $entity->basic_id;
        }
        db_delete('edoweb_basic')
          ->condition('basic_id', $basic_ids, 'IN')
          ->execute();
      }
      catch (Exception $e) {
        $transaction->rollback();
        watchdog_exception('edoweb', $e);
        throw $e;
      }
    }
  }

}

/*
 * An interface to lobid.org
 */
class LinkedDataClient {

  /*
   * Load an entity from the API.
   *
   * @param $entity
   *   The drupal entity to load data into
   */
  public function load($entity, $resource_uri) {
    $request_url = $resource_uri;
    $http_options = array(
      'method' => 'GET',
      'headers' => array('Accept' => 'application/rdf+xml'),
    );
    $http_response = drupal_http_request($request_url, $http_options);
    // FIXME: drupal_http_request does not follow 303s
    if (303 == $http_response->code) {
      $redirect_url = $http_response->headers['location'];
      if ("/" == substr($redirect_url, 0, 1)) {
        $parsed_url = parse_url($request_url);
        $redirect_url = "{$parsed_url['scheme']}://{$parsed_url['host']}$redirect_url";
      }
      $request_url = $redirect_url;
      $http_response = drupal_http_request($request_url, $http_options);
    }
    $rdf_data = $http_response->data;
    $rdf_subject = new LibRDF_URINode($resource_uri);
    $rdf_parser = new LibRDF_Parser('rdfxml');
    _edoweb_entity_deserialize_rdf($entity, $rdf_subject, $rdf_data, $rdf_parser);
    $entity->origin = $resource_uri;
    return TRUE;
  }

}

interface EdowebAPIClientInterface {
  public function load($entity);
  public function save($entity);
}

/*
 * An edoweb api client that acts on local files.
 */
class EdowebAPIClientLocal implements EdowebAPIClientInterface {

  /*
   * Load an entity from the API.
   *
   * @param $entity
   *   The drupal entity to load data into
   */
  public function load($entity) {
    $rdf_subject = new LibRDF_URINode("uuid:{$entity->basic_id}");
    $rdf_data = file_get_contents("/tmp/{$entity->basic_id}.ttl");
    $rdf_parser = new LibRDF_Parser('turtle');
    _edoweb_entity_deserialize_rdf($entity, $rdf_subject, $rdf_data, $rdf_parser);
    return TRUE;
  }

  /*
   * Save an entity to the API
   *
   * @param $entity
   *   The drupal entity to store data from
   *
   */
  public function save($entity) {
    $json = _edoweb_entity_serialize_jsonld($entity);
    $rdf = _edoweb_entity_serialize_turtle($entity);
    file_put_contents("/tmp/{$entity->basic_id}.ttl", $rdf);
    file_put_contents("/tmp/{$entity->basic_id}.json", $json);
    return TRUE;
  }

}

class EdowebAPIClient implements EdowebAPIClientInterface {

  /*
   * The URL of the Edoweb API
   */
  private $__edoweb_api_host = 'orthos.hbz-nrw.de';

  /**
   * The username for the Edoweb API
   *
   */
  private $__edoweb_api_user = 'fedoraAdmin';

  /**
   * The password for the Edoweb API
   *
   */
  private $__edoweb_api_pass = 'fedoraAdmin1';

  /*
   * Load an entity from the API.
   *
   * @param $entity
   *   The drupal entity to load data into
   */
  public function load($entity) {
    $rdf_subject = new LibRDF_URINode("uuid:{$entity->basic_id}");
    $rdf_data = file_get_contents("/tmp/{$entity->basic_id}.ttl");
    $rdf_parser = new LibRDF_Parser('turtle');
    _edoweb_entity_deserialize_rdf($entity, $rdf_subject, $rdf_data, $rdf_parser);
    return TRUE;
  }

  /*
   * Save an entity to the API
   *
   * @param $entity
   *   The drupal entity to store data from
   *
   */
  public function save($entity) {
    $http_post_data = _edoweb_entity_serialize_jsonld($entity);
    $http_url = "http://{$this->__edoweb_api_user}:{$this->__edoweb_api_pass}@{$this->__edoweb_api_host}/monograph/edoweb:{$entity->basic_id}/metadata";
    $http_response = $this->_http_post($http_url, $http_post_data);

    // Display response in UI
    $status_type = 'error';
    switch ($http_response->code[0]) {
      case '2':
        $status_type = 'status';
        break;
      case '3':
        $status_type = 'warning';
        break;
    }
    drupal_set_message(
      sprintf("API call to %s responded with HTTP %s.<pre>{%s}</pre>",
              $http_url, $http_response->code, htmlentities(print_r($http_response, TRUE))
      ), $status_type
    );
  }

  protected function _http_put($request_url, $request_body) {
    $http_options = array(
      'method' => 'PUT',
      'data' => $request_body,
    );
    $http_response = drupal_http_request($request_url, $http_options);
    return $http_response;
  }

  protected function _http_post($request_url, $request_body) {
    $http_options = array(
      'method' => 'POST',
      'data' => $request_body,
      'headers' => array('Content-Type' => 'application/json'),
    );
    $http_response = drupal_http_request($request_url, $http_options);
    return $http_response;
  }

}
